{"version":3,"sources":["assets/nocover.jpeg","components/Cover/Cover.tsx","components/Cover/LinkCover.tsx","components/MediaGrid/MediaGrid.tsx","types/SheetsAPI.ts","api/sheets/sheets.ts","types/Media.ts","api.ts","components/Loading/Loading.tsx","components/MediaGrid/SheetsMediaGrid.tsx","pages/App.tsx","pages/MediaInfo/MediaInfo.tsx","MainLayout.tsx","components/Header.tsx","routing/AppRouter.tsx","serviceWorker.js","index.js","components/Cover/Cover.module.css","components/Loading/Loading.module.css"],"names":["module","exports","Cover","cover","nocover","chapters","chapters_read","title","_key","is_reading","progress_reading","progress_unread","key","className","styles","text","src","alt","draggable","image","LinkCover","item","basepath","props","destination","id","to","MediaGrid","media","media_items","useMemo","map","user","chaptersread","entry_schema","object","shape","$t","string","response_schema","feed","updated","date","entry","array","of","buildSheetsUrl","doc_id","sheet_number","fetchSheet","a","url","fetch","response","json","raw_data","cast","message","parseResponse","raw","data","prefix","res","Object","keys","forEach","indexOf","label","substr","length","removeKeyPrefix","retrive","raw_sheet","sheet","media_schema","yup","notRequired","integer","DOC_KEY","default","fetchGlobalMediaList","medialist","err","filter","notUndefined","hasId","fetchUserMediaList","userdatalist","Promise","all","global_media","user_media","global_map","Map","g","user_map","u","combineUserData","global_data","user_data","combined_data","set","get","Array","from","values","Boolean","Loading","console","log","container","SheetsMediaGrid","useState","setMedia","loading","setLoading","useEffect","fetchCombinedMediaList","then","combined_list","catch","reason","error","GridComp","LoadingComp","App","MediaInfo","MediaInfoRoute","match","m","params","MainLayout","header","children","Header","AppRouter","basename","exact","path","name","component","window","location","hostname","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.816dcc0e.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/nocover.4a631526.jpeg\";","import React from 'react'\r\nimport Media from '../../types/Media'\r\nimport styles from './Cover.module.css'\r\nimport nocover from '../../assets/nocover.jpeg'\r\n\r\nexport interface CoverProps extends Media {\r\n    chapters_read?: number\r\n    _key?: string | number\r\n}\r\n\r\n/**\r\n * Display a single cover for some peice of media\r\n */\r\nfunction Cover({\r\n    cover = nocover,\r\n    chapters = 0,\r\n    chapters_read = 0,\r\n    title = 'MISSING TITLE',\r\n    _key,\r\n}: CoverProps) {\r\n    const is_reading = chapters_read > 0\r\n\r\n    const progress_reading = `${chapters_read} / ${chapters}`\r\n    const progress_unread = `${chapters} Chapters`\r\n\r\n    return (\r\n        <li key={_key} className={styles.cover}>\r\n            <div className={styles.text}>\r\n                <p>{title}</p>\r\n                <p>{is_reading ? progress_reading : progress_unread}</p>\r\n            </div>\r\n            <img\r\n                src={cover}\r\n                alt=''\r\n                draggable={false}\r\n                className={styles.image}\r\n            />\r\n        </li>\r\n    )\r\n}\r\n\r\nexport default Cover\r\n","import React from 'react'\r\nimport { Link } from 'react-router-dom'\r\n\r\nimport Media from '../../types/Media'\r\nimport Cover, { CoverProps } from './Cover'\r\n\r\ninterface LinkCoverProps extends CoverProps {\r\n    basepath?: string\r\n    item?: Media\r\n    chapters_read?: number\r\n    _key?: string | number\r\n}\r\n\r\nfunction LinkCover({\r\n    chapters_read,\r\n    item,\r\n    basepath = '/media/',\r\n    _key,\r\n    ...props\r\n}: LinkCoverProps) {\r\n    const page = item ? item.id : ''\r\n    const destination = basepath + page\r\n    return (\r\n        <Link to={destination} key={_key}>\r\n            <Cover chapters_read={chapters_read} {...props}></Cover>\r\n        </Link>\r\n    )\r\n}\r\n\r\nexport default LinkCover\r\n","import React, { useMemo } from 'react'\r\nimport Media, { CombinedMedia } from '../../types/Media'\r\nimport LinkCover from '../Cover/LinkCover'\r\n\r\ntype MediaGridProps = {\r\n    media?: CombinedMedia[]\r\n}\r\n\r\n/**\r\n *\r\n */\r\nfunction MediaGrid({ media = [] }: MediaGridProps) {\r\n    const media_items = useMemo(() => {\r\n        return media.map(({ media, user }) => {\r\n            return LinkCover({\r\n                chapters_read: user && user.chaptersread,\r\n                _key: media.id,\r\n                ...media,\r\n            })\r\n        })\r\n    }, [media])\r\n\r\n    return <ul className='media-grid'>{media_items}</ul>\r\n}\r\n\r\nexport default MediaGrid\r\n","import { object, array, InferType, string, date } from 'yup'\r\n\r\nconst entry_schema = object().shape({\r\n    title: object().shape({\r\n        $t: string(),\r\n    }),\r\n})\r\n\r\nconst response_schema = object().shape({\r\n    feed: object().shape({\r\n        title: object().shape({\r\n            $t: string(),\r\n        }),\r\n        updated: object().shape({\r\n            $t: date(),\r\n        }),\r\n        entry: array().of(entry_schema),\r\n    }),\r\n})\r\n\r\n/**\r\n * Response from the sheets api\r\n */\r\nexport type Response = InferType<typeof response_schema>\r\n\r\n/**\r\n * A single entry in the respose list\r\n */\r\nexport type Entry = InferType<typeof entry_schema>\r\n\r\nexport { response_schema, entry_schema }\r\n","import {\r\n    Entry as SheetsEntry,\r\n    Response as SheetsResponse,\r\n    response_schema,\r\n} from '../../types/SheetsAPI'\r\n\r\nfunction buildSheetsUrl(doc_id: string, sheet_number: number) {\r\n    return `https://spreadsheets.google.com/feeds/list/${doc_id}/${sheet_number}/public/values?alt=json`\r\n}\r\n\r\nexport async function fetchSheet(doc_id: string, sheet_number: number) {\r\n    const url = buildSheetsUrl(doc_id, sheet_number)\r\n\r\n    try {\r\n        const response = await fetch(url)\r\n        const raw_data = await response.json()\r\n        return response_schema.cast(raw_data)\r\n    } catch (error) {\r\n        error.message += 'Failed to fetch sheet:'\r\n        error.doc_id = doc_id\r\n        error.sheet_number = sheet_number\r\n        throw error\r\n    }\r\n}\r\n\r\nexport function parseResponse(raw: SheetsResponse) {\r\n    const data = parseLabeledCols(raw.feed.entry)\r\n    const res = {\r\n        title: raw.feed.title.$t,\r\n        updated: raw.feed.updated.$t,\r\n        data,\r\n    }\r\n    return res\r\n}\r\n\r\n/**\r\n * Remove the given prefix from where\r\n */\r\nfunction removeKeyPrefix(entry: SheetsEntry, prefix: string): object {\r\n    const res: any = {}\r\n    Object.keys(entry).forEach(key => {\r\n        if (key.indexOf(prefix) === 0) {\r\n            const label = key.substr(prefix.length)\r\n            res[label] = (entry as any)[key].$t\r\n        }\r\n    })\r\n    return res\r\n}\r\n\r\n/**\r\n * Parser for table where just the columns are labeled\r\n * @return array of objects where the labels are keys\r\n */\r\nfunction parseLabeledCols(entries: SheetsEntry[]) {\r\n    return entries.map(entry => removeKeyPrefix(entry, 'gsx$'))\r\n}\r\n\r\n/**\r\n * Retrive data from a google docs DB.\r\n * Each row is treated as an object, with the top columns being the object keys and the others being the values\r\n */\r\nexport async function retrive(doc_id: string, sheet_number: number) {\r\n    const raw_sheet = await fetchSheet(doc_id, sheet_number)\r\n    const sheet = parseResponse(raw_sheet)\r\n    return sheet\r\n}\r\n","import * as yup from 'yup'\r\n\r\nconst media_schema = yup.object().shape({\r\n    id: yup.string(),\r\n    title: yup.string().notRequired(),\r\n    chapters: yup\r\n        .number()\r\n        .integer()\r\n        .notRequired(),\r\n    cover: yup\r\n        .string()\r\n        .url()\r\n        .notRequired(),\r\n})\r\n\r\nconst user_media_schema = yup.object().shape({\r\n    id: yup.string(),\r\n    chaptersread: yup\r\n        .number()\r\n        .integer()\r\n        .notRequired()\r\n        .default(0),\r\n})\r\n\r\n/**\r\n * Represents a single peice of serializeable media (it has chapters)\r\n */\r\ntype Media = yup.InferType<typeof media_schema>\r\n\r\n/**\r\n * Represents the data a user has for this media.\r\n * Mostly used to see how many chapters a user has read.\r\n * In future it can be used for\r\n */\r\nexport type UserMedia = yup.InferType<typeof user_media_schema>\r\n\r\nexport type MediaOrUndefined = Media | undefined\r\n\r\n/**\r\n * Generic media and specific user data merged together.\r\n * User may not have data about this media, so it s optional\r\n */\r\nexport type CombinedMedia = {\r\n    media: Media\r\n    user?: UserMedia\r\n}\r\n\r\nexport default Media\r\nexport { media_schema, user_media_schema }\r\n","import { retrive } from './api/sheets/sheets'\r\nimport Media, { UserMedia, CombinedMedia, media_schema } from './types/Media'\r\n\r\nconst DOC_KEY = '1h64ICq9bDipGdd8Wz_ZvdPrnh3CAOTixMrZINzUsTiY'\r\n\r\nexport async function fetchGlobalMediaList() {\r\n    const sheet = await retrive(DOC_KEY, 1)\r\n    const medialist: Media[] = sheet.data as any[]\r\n\r\n    const cast = (media: Media): Media => {\r\n        try {\r\n            return media_schema.cast(media)\r\n        } catch (err) {}\r\n        return media\r\n    }\r\n\r\n    return medialist\r\n        .map(cast)\r\n        .filter(notUndefined)\r\n        .filter(hasId)\r\n}\r\n\r\nexport async function fetchUserMediaList() {\r\n    const sheet = await retrive(DOC_KEY, 2)\r\n    const userdatalist: UserMedia[] = sheet.data as any[]\r\n\r\n    return userdatalist.filter(notUndefined).filter(hasId)\r\n}\r\n\r\nexport async function fetchCombinedMediaList() {\r\n    const [global_media, user_media] = await Promise.all([\r\n        fetchGlobalMediaList(),\r\n        fetchUserMediaList(),\r\n    ])\r\n\r\n    const global_map = new Map(global_media.map(g => [g.id, g]))\r\n    const user_map = new Map(user_media.map(u => [u.id, u]))\r\n\r\n    return combineUserData(global_map, user_map)\r\n}\r\n\r\nexport async function getGlobalMedia(id: string) {\r\n    const medialist = await fetchGlobalMediaList()\r\n    const result = medialist.find(media => media.id === id)\r\n    if (!result) throw new Error(`Could not find global media with id \"${id}\"`)\r\n    return result\r\n}\r\n\r\nexport async function getUserMedia(id: string) {\r\n    const medialist = await fetchUserMediaList()\r\n    const result = medialist.find(media => media.id === id)\r\n    if (!result) throw new Error(`Could not find user media with id \"${id}\"`)\r\n    return result\r\n}\r\n\r\n/**\r\n * Find user data for the given media, if it exits\r\n */\r\nfunction combineUserData(\r\n    global_data: Map<String, Media>,\r\n    user_data: Map<String, UserMedia>\r\n): CombinedMedia[] {\r\n    const combined_data = new Map<String, CombinedMedia>()\r\n\r\n    global_data.forEach(media => {\r\n        combined_data.set(media.id, {\r\n            media,\r\n        })\r\n    })\r\n\r\n    user_data.forEach(user => {\r\n        const media = global_data.get(user.id)\r\n        if (media) {\r\n            combined_data.set(user.id, {\r\n                media,\r\n                user,\r\n            })\r\n        }\r\n    })\r\n\r\n    return Array.from(combined_data.values())\r\n}\r\n\r\nfunction notUndefined<T>(item: T): item is T {\r\n    return Boolean(item)\r\n}\r\n\r\ntype ObjectWithId = {\r\n    id: string\r\n}\r\n\r\nconst hasId = (item: ObjectWithId) => Boolean(item.id)\r\n","import React from 'react'\r\n\r\nimport styles from './Loading.module.css'\r\n\r\ninterface LoadingProps {\r\n    className?: string\r\n}\r\n\r\nfunction Loading({ className, ...props }: LoadingProps) {\r\n    console.log('load')\r\n    return (\r\n        <div className={`${styles.container} ${className || ''}`} {...props}>\r\n            <h1 className={styles.text}>Loading...</h1>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default Loading\r\n","import React, { FunctionComponent, useEffect, useState } from 'react'\r\nimport MediaGrid from './MediaGrid'\r\nimport { fetchCombinedMediaList } from '../../api'\r\nimport { CombinedMedia } from '../../types/Media'\r\nimport Loading from '../Loading/Loading'\r\n\r\ntype SheetsMediaGridProps = {}\r\n\r\nconst SheetsMediaGrid: FunctionComponent<SheetsMediaGridProps> = ({\r\n    ...props\r\n}) => {\r\n    const [media, setMedia] = useState<CombinedMedia[]>([])\r\n    const [loading, setLoading] = useState(false)\r\n    console.log('render')\r\n\r\n    useEffect(() => {\r\n        setLoading(true)\r\n        fetchCombinedMediaList()\r\n            .then(combined_list => {\r\n                setMedia(combined_list)\r\n                setLoading(false)\r\n            })\r\n            .catch(reason => {\r\n                console.error('Could not get media list: ', reason)\r\n            })\r\n    }, [])\r\n\r\n    const GridComp = <MediaGrid media={media} {...props} />\r\n    const LoadingComp = <Loading />\r\n    return loading ? LoadingComp : GridComp\r\n}\r\n\r\nexport default SheetsMediaGrid\r\n","import React from 'react'\r\n\r\nimport './App.css'\r\nimport SheetsMediaGrid from '../components/MediaGrid/SheetsMediaGrid'\r\n\r\nfunction App() {\r\n    return <SheetsMediaGrid />\r\n}\r\n\r\nexport default App\r\n","import React from 'react'\r\nimport Media from '../../types/Media'\r\n\r\nimport { RouteComponentProps } from 'react-router-dom'\r\n\r\ntype MediaInfoProps = {\r\n    media: Media\r\n}\r\n\r\nexport default function MediaInfo({ media }: MediaInfoProps) {\r\n    return <h1>{media && media.id}</h1>\r\n}\r\n\r\ntype RouteParams = {\r\n    id: string\r\n}\r\n\r\nexport function MediaInfoRoute({\r\n    match,\r\n    ...props\r\n}: RouteComponentProps<RouteParams>) {\r\n    const m: Media = {\r\n        id: match.params.id,\r\n        chapters: 10,\r\n        cover: '',\r\n        title: '',\r\n    }\r\n    return <MediaInfo media={m} {...props} />\r\n}\r\n","import React, { FunctionComponent } from 'react'\r\n\r\ntype MainLayoutProps = {\r\n    className?: String\r\n    header: React.ReactNode\r\n}\r\n\r\nconst MainLayout: FunctionComponent<MainLayoutProps> = ({\r\n    className = '',\r\n    header,\r\n    children,\r\n    ...props\r\n}) => (\r\n    <div className={`main-layout ${className}`} {...props}>\r\n        {header}\r\n        <div className='main-content'>{children}</div>\r\n    </div>\r\n)\r\n\r\nexport default MainLayout\r\n","import React from 'react'\r\n\r\nfunction Header() {\r\n    return (\r\n        <header className=\"mw-header\">\r\n            <h1 className=\"title\">MangaWatch</h1>\r\n            <div className=\"nav\">\r\n                <h2>User</h2>\r\n                <h2>Settings</h2>\r\n            </div>\r\n        </header>\r\n    )\r\n}\r\n\r\nexport default Header\r\n","import React from 'react'\r\nimport { BrowserRouter as Router, Route, Switch } from 'react-router-dom'\r\nimport App from '../pages/App'\r\nimport { MediaInfoRoute } from '../pages/MediaInfo/MediaInfo'\r\nimport MainLayout from '../MainLayout'\r\nimport Header from '../components/Header'\r\n\r\nfunction AppRouter() {\r\n    return (\r\n        <MainLayout header={<Header />} className='app'>\r\n            <Router basename='/mediawatch'>\r\n                <Switch>\r\n                    <Route exact path='/' name='Mangawatch' component={App} />\r\n                    <Route path='/list' />\r\n                    <Route path='/user' />\r\n                    <Route path='/media/:id' component={MediaInfoRoute} />\r\n                    <Route path='' component={() => <h1>404</h1>} />\r\n                </Switch>\r\n            </Router>\r\n        </MainLayout>\r\n    )\r\n}\r\n\r\nexport default AppRouter\r\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n    window.location.hostname === 'localhost' ||\n        // [::1] is the IPv6 localhost address.\n        window.location.hostname === '[::1]' ||\n        // 127.0.0.1/8 is considered localhost for IPv4.\n        window.location.hostname.match(\n            /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n        )\n)\n\nexport function register(config) {\n    if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n        // The URL constructor is available in all browsers that support SW.\n        const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href)\n        if (publicUrl.origin !== window.location.origin) {\n            // Our service worker won't work if PUBLIC_URL is on a different origin\n            // from what our page is served on. This might happen if a CDN is used to\n            // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n            return\n        }\n\n        window.addEventListener('load', () => {\n            const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`\n\n            if (isLocalhost) {\n                // This is running on localhost. Let's check if a service worker still exists or not.\n                checkValidServiceWorker(swUrl, config)\n\n                // Add some additional logging to localhost, pointing developers to the\n                // service worker/PWA documentation.\n                navigator.serviceWorker.ready.then(() => {\n                    console.log(\n                        'This web app is being served cache-first by a service ' +\n                            'worker. To learn more, visit https://bit.ly/CRA-PWA'\n                    )\n                })\n            } else {\n                // Is not localhost. Just register service worker\n                registerValidSW(swUrl, config)\n            }\n        })\n    }\n}\n\nfunction registerValidSW(swUrl, config) {\n    navigator.serviceWorker\n        .register(swUrl)\n        .then(registration => {\n            registration.onupdatefound = () => {\n                const installingWorker = registration.installing\n                if (installingWorker == null) {\n                    return\n                }\n                installingWorker.onstatechange = () => {\n                    if (installingWorker.state === 'installed') {\n                        if (navigator.serviceWorker.controller) {\n                            // At this point, the updated precached content has been fetched,\n                            // but the previous service worker will still serve the older\n                            // content until all client tabs are closed.\n                            console.log(\n                                'New content is available and will be used when all ' +\n                                    'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n                            )\n\n                            // Execute callback\n                            if (config && config.onUpdate) {\n                                config.onUpdate(registration)\n                            }\n                        } else {\n                            // At this point, everything has been precached.\n                            // It's the perfect time to display a\n                            // \"Content is cached for offline use.\" message.\n                            console.log('Content is cached for offline use.')\n\n                            // Execute callback\n                            if (config && config.onSuccess) {\n                                config.onSuccess(registration)\n                            }\n                        }\n                    }\n                }\n            }\n        })\n        .catch(error => {\n            console.error('Error during service worker registration:', error)\n        })\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n    // Check if the service worker can be found. If it can't reload the page.\n    fetch(swUrl)\n        .then(response => {\n            // Ensure service worker exists, and that we really are getting a JS file.\n            const contentType = response.headers.get('content-type')\n            if (\n                response.status === 404 ||\n                (contentType != null &&\n                    contentType.indexOf('javascript') === -1)\n            ) {\n                // No service worker found. Probably a different app. Reload the page.\n                navigator.serviceWorker.ready.then(registration => {\n                    registration.unregister().then(() => {\n                        window.location.reload()\n                    })\n                })\n            } else {\n                // Service worker found. Proceed as normal.\n                registerValidSW(swUrl, config)\n            }\n        })\n        .catch(() => {\n            console.log(\n                'No internet connection found. App is running in offline mode.'\n            )\n        })\n}\n\nexport function unregister() {\n    if ('serviceWorker' in navigator) {\n        navigator.serviceWorker.ready.then(registration => {\n            registration.unregister()\n        })\n    }\n}\n","import React from 'react'\r\nimport ReactDOM from 'react-dom'\r\nimport './index.css'\r\nimport AppRouter from './routing/AppRouter'\r\nimport * as serviceWorker from './serviceWorker'\r\n\r\nReactDOM.render(<AppRouter />, document.getElementById('root'))\r\n\r\n// If you want your app to work offline and load faster, you can change\r\n// unregister() to register() below. Note this comes with some pitfalls.\r\n// Learn more about service workers: https://bit.ly/CRA-PWA\r\nserviceWorker.unregister()\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"cover\":\"Cover_cover__2OrmH\",\"text\":\"Cover_text__2IwmS\",\"image\":\"Cover_image__3_lUE\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"container\":\"Loading_container__1psUk\",\"text\":\"Loading_text__Bcsf8\"};"],"sourceRoot":""}